---
description: "QuantConnect Volatility-Arbitrage ‚Äì Cursor Rules"
globs:
  - "**/*.py"
alwaysApply: true
---

# QuantConnect Volatility-Arbitrage ‚Äì Cursor Rules

## üéØ CORE PRINCIPLES

### 0. LEAN-FIRST DEVELOPMENT  üö® PRIMARY DIRECTIVE
**Always confirm whether QuantConnect/LEAN already offers the needed feature before rolling your own.**

### ‚ö†Ô∏è  CRITICAL: QUANTCONNECT `Symbol` OBJECT LIMITATION
*Never pass QC `Symbol` objects to Python constructors (causes ‚Äúerror return without exception set‚Äù).*

**Forbidden pattern**
```python
# ‚ùå Will crash algorithm initialisation
my_component = MyComponent(self, [equity_symbol, option_symbol])
```

**Correct pattern**
```python
# ‚úÖ Use strings or let LEAN manage Symbol creation internally
symbol_strings = [s.Value for s in symbol_objects]
my_component = MyComponent(self, symbol_strings)
```

---

## 1Ô∏è‚É£  USE QC BUILT-IN CAPABILITIES

Lean already provides:

* Portfolio tracking ‚Äì `self.Portfolio[...]`
* Standard indicators ‚Äì `self.SMA`, `self.RSI`, `self.BB`, etc.
* Order management ‚Äì `self.MarketOrder`, `self.SetHoldings`
* Option chain access ‚Äì `self.AddOption`, `OptionChains[...]`
* Scheduling ‚Äì `self.Schedule.On`

**Never re-implement these.**

---

## 2Ô∏è‚É£  OPTION-CHAIN PERFORMANCE BEST PRACTICES  (PROJECT-SPECIFIC)

1. **Resolution**
   Use `Resolution.Daily` (or `Hour`) for options unless intraday granularity is required.
   ```python
   option = self.AddOption("AAPL", Resolution.Daily)
   ```

2. **Strike & expiry filters**
   Keep filters tight to reduce slice size:
   ```python
   option.SetFilter(-5, 5, timedelta(15), timedelta(45))
   ```

3. **Throttle calculations**
   ‚Ä¢ Compute implied volatility (IV) only when you rebalance (monthly/weekly).
   ‚Ä¢ Cache IV in a dictionary with time stamps instead of recalculating every day.

4. **Avoid full chain scans inside warm-up**
   During warm-up use historical IV data **or** skip IV until `OnWarmupFinished`.

---

## 3Ô∏è‚É£  ZERO-HARDCODED VALUES POLICY

All strategy parameters (look-backs, moneyness, thresholds) live in a **single** `config.json` or equivalent and are validated on startup.

---

## 4Ô∏è‚É£  WARM-UP GUIDELINES

* Use `self.SetWarmUp(timedelta(days=<calculated>))`
* Differentiate behaviour with `self.IsWarmingUp`.
* Use `OnWarmupFinished` to verify indicators and state.

---

## 5Ô∏è‚É£  MODULAR DESIGN (SOFT GUIDELINE)

Keep files < 64 KB; separate:

* `strategy/`  ‚Äì signal generation (HV vs IV logic)
* `execution/` ‚Äì order placement / straddles
* `risk/`      ‚Äì max position size, portfolio allocation

---

## 6Ô∏è‚É£  CONFIGURATION SECURITY

* Centralise configuration access (`ConfigManager` pattern if desired).
* Fail fast on missing/invalid parameters.
* No silent fallbacks.

---

## SECURITY CHECKLIST

- [ ] No custom portfolio tracking (use `self.Portfolio`)
- [ ] No custom indicator math if QC provides it
- [ ] No direct config dictionary reads ‚Äì validated access only
- [ ] No hard-coded thresholds inside algorithm logic
- [ ] Warm-up logic separated from live trading logic
- [ ] Option chain resolution & filters reviewed for performance
- [ ] No Symbol objects passed across class boundaries

---

## QUICK REFERENCE ‚Äì COMMON LEAN METHODS

```python
# Portfolio / Orders
self.Portfolio.TotalPortfolioValue
self.Portfolio[symbol].Quantity
self.MarketOrder(symbol, qty)
self.LimitOrder(symbol, qty, price)
self.Liquidate(symbol)

# Data / Indicators
hist = self.History(symbol, 252, Resolution.Daily)
sma  = self.SMA(symbol, 20)   # auto-warmed

# Scheduling
self.Schedule.On(self.DateRules.MonthEnd(), self.TimeRules.AfterMarketOpen("SPY", 30), self.Rebalance)

# Option chains
option = self.AddOption("AAPL", Resolution.Daily)
option.SetFilter(-5, 5, timedelta(15), timedelta(45))
chain  = slice.OptionChains.get(option.Symbol)
```

---

Keep these guidelines in `.cursor/rules` so Cursor applies them automatically for all contributors. 